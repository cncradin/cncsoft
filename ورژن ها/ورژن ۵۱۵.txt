from PyQt5 import QtWidgets
from PyQt5.QtWidgets import QApplication, QFileDialog, QGraphicsScene, QGraphicsView, QGraphicsLineItem, QGraphicsEllipseItem, QGraphicsRectItem, QLabel, QLineEdit, QGraphicsTextItem, QDialog, QVBoxLayout, QHBoxLayout, QWidget, QPushButton, QMenuBar, QMenu, QGraphicsItem, QGraphicsItemGroup, QComboBox, QDialogButtonBox, QCheckBox, QSplitter, QSlider, QShortcut, QTextEdit, QGridLayout, QButtonGroup, QListWidgetItem
from PyQt5.QtCore import Qt, QPointF, QRectF, QUrl, QDir, QTimer, QPropertyAnimation, QObject, pyqtProperty, pyqtSignal
from PyQt5.QtGui import QPen, QColor, QPainter, QBrush, QPixmap, QPainterPath, QPainterPathStroker, QIcon, QKeySequence, QTextCharFormat, QTextCursor
from PyQt5.QtCore import QStandardPaths
import ezdxf
import sys
import numpy as np
import math
import json
import os
import re

COLOR_PALETTE = [
    QColor(255, 0, 0), QColor(0, 255, 0), QColor(0, 0, 255), QColor(255, 255, 0),
    QColor(255, 165, 0), QColor(128, 0, 128), QColor(255, 105, 180), QColor(139, 69, 19),
    QColor(0, 0, 0), QColor(255, 255, 255), QColor(128, 128, 128), QColor(0, 255, 255),
]

# دیکشنری ترجمه کامل
TRANSLATIONS = {
    "English": {
        "file_menu": "File",
        "import_action": "Import File",
        "edit_menu": "Edit",
        "config_menu": "Config",
        "help_menu": "Help",
        "table_config_action": "Table Setup",
        "language_menu": "Language",
        "english_action": "English",
        "persian_action": "Persian",
        "generate_gcode": "Generate G-Code",
        "delete_selected": "Delete Selected",
        "undo": "Undo",
        "redo": "Redo",
        "speed_label": "Speed (F):",
        "power_label": "Power (S):",
        "mouse_x_label": "Mouse X:",
        "mouse_y_label": "Mouse Y:",
        "no_file_selected": "No file selected",
        "table_profile_label": "Table Profile:",
        "table_width_label": "Table Width (mm):",
        "table_height_label": "Table Height (mm):",
        "simulation_window": "Simulation Window",
        "gcode_display_label": "Generated G-Code:",
        "table_size_updated": "Table size updated successfully",
        "invalid_table_dimensions": "Invalid table dimensions",
        "table_dimensions_positive": "Table dimensions must be positive",
        "error_loading_settings": "Error loading settings: {error}",
        "loaded_dxf_file": "Loaded DXF file: {filename}",
        "error_loading_dxf_permission": "Error loading DXF file: Permission denied - {error}",
        "error_loading_dxf_not_found": "Error loading DXF file: File not found - {error}",
        "error_loading_dxf": "Error loading DXF file: {error}",
        "no_paths_for_gcode": "No paths to generate G-Code",
        "invalid_speed_power": "Invalid speed or power value",
        "speed_power_positive": "Speed and power must be positive",
        "gcode_generated": "G-Code generated successfully",
        "no_valid_points_gcode": "No valid points found for G-Code",
        "no_gcode_for_simulation": "No G-Code available for simulation",
        "all_items_selected": "All items selected",
        "no_items_to_delete": "No items selected to delete",
        "deleted_items": "Deleted {count} items",
        "no_valid_items_to_delete": "No valid items to delete",
        "restored_items": "Restored {count} items",
        "nothing_to_undo": "Nothing to undo",
        "undid_move": "Undid move for {count} items",
        "undid_color_change": "Undid color change for {count} items",
        "redeleted_items": "Re-deleted {count} items",
        "redid_move": "Redid move for {count} items",
        "redid_color_change": "Redid color change for {count} items",
        "nothing_to_redo": "Nothing to redo",
        "color_changed": "Color changed for {count} items",
        "no_items_to_change_color": "No items selected to change color",
        "zero_point_set": "Zero point set to {corner}",
        "error_saving_zero_point": "Error saving zero point: {error}",
        "language_saved": "Language set to {language}",
        "error_saving_language": "Error saving language: {error}"
    },
    "Persian": {
        "file_menu": "فایل",
        "import_action": "وارد کردن فایل",
        "edit_menu": "ویرایش",
        "config_menu": "پیکربندی",
        "help_menu": "راهنما",
        "table_config_action": "تنظیمات میز",
        "language_menu": "زبان",
        "english_action": "انگلیسی",
        "persian_action": "فارسی",
        "generate_gcode": "تولید G-Code",
        "delete_selected": "حذف انتخاب‌شده‌ها",
        "undo": "بازگشت",
        "redo": "تکرار",
        "speed_label": "سرعت (F):",
        "power_label": "قدرت (S):",
        "mouse_x_label": "مختصات X ماوس:",
        "mouse_y_label": "مختصات Y ماوس:",
        "no_file_selected": "هیچ فایلی انتخاب نشده",
        "table_profile_label": "پروفایل میز:",
        "table_width_label": "عرض میز (میلی‌متر):",
        "table_height_label": "ارتفاع میز (میلی‌متر):",
        "simulation_window": "پنجره شبیه‌سازی",
        "gcode_display_label": "G-Code تولیدشده:",
        "table_size_updated": "اندازه میز با موفقیت به‌روزرسانی شد",
        "invalid_table_dimensions": "ابعاد میز نامعتبر است",
        "table_dimensions_positive": "ابعاد میز باید مثبت باشد",
        "error_loading_settings": "خطا در بارگذاری تنظیمات: {error}",
        "loaded_dxf_file": "فایل DXF بارگذاری شد: {filename}",
        "error_loading_dxf_permission": "خطا در بارگذاری فایل DXF: دسترسی غیرمجاز - {error}",
        "error_loading_dxf_not_found": "خطا در بارگذاری فایل DXF: فایل یافت نشد - {error}",
        "error_loading_dxf": "خطا در بارگذاری فایل DXF: {error}",
        "no_paths_for_gcode": "هیچ مسیری برای تولید G-Code وجود ندارد",
        "invalid_speed_power": "مقدار سرعت یا قدرت نامعتبر است",
        "speed_power_positive": "سرعت و قدرت باید مثبت باشد",
        "gcode_generated": "G-Code با موفقیت تولید شد",
        "no_valid_points_gcode": "هیچ نقطه معتبری برای G-Code یافت نشد",
        "no_gcode_for_simulation": "هیچ G-Code‌ای برای شبیه‌سازی در دسترس نیست",
        "all_items_selected": "همه آیتم‌ها انتخاب شدند",
        "no_items_to_delete": "هیچ آیتمی برای حذف انتخاب نشده",
        "deleted_items": "{count} آیتم حذف شد",
        "no_valid_items_to_delete": "هیچ آیتم معتبری برای حذف وجود ندارد",
        "restored_items": "{count} آیتم بازیابی شد",
        "nothing_to_undo": "چیزی برای بازگشت وجود ندارد",
        "undid_move": "جابجایی {count} آیتم بازگشت شد",
        "undid_color_change": "تغییر رنگ {count} آیتم بازگشت شد",
        "redeleted_items": "{count} آیتم دوباره حذف شد",
        "redid_move": "جابجایی {count} آیتم دوباره انجام شد",
        "redid_color_change": "تغییر رنگ {count} آیتم دوباره انجام شد",
        "nothing_to_redo": "چیزی برای تکرار وجود ندارد",
        "color_changed": "رنگ {count} آیتم تغییر کرد",
        "no_items_to_change_color": "هیچ آیتمی برای تغییر رنگ انتخاب نشده",
        "zero_point_set": "نقطه صفر به {corner} تنظیم شد",
        "error_saving_zero_point": "خطا در ذخیره نقطه صفر: {error}",
        "language_saved": "زبان به {language} تنظیم شد",
        "error_saving_language": "خطا در ذخیره زبان: {error}"
    }
}

def find_closest_color(color):
    r1, g1, b1 = color.red(), color.green(), color.blue()
    min_distance = float('inf')
    closest_color = COLOR_PALETTE[0]
    closest_index = 0
    for i, palette_color in enumerate(COLOR_PALETTE):
        r2, g2, b2 = palette_color.red(), palette_color.green(), palette_color.blue()
        distance = math.sqrt((r1 - r2) ** 2 + (g1 - g2) ** 2 + (b1 - b2) ** 2)
        if distance < min_distance:
            min_distance = distance
            closest_color = palette_color
            closest_index = i
    return closest_color, closest_index

def aci_to_qcolor(aci):
    aci_colors = {
        1: (255, 0, 0), 2: (255, 255, 0), 3: (0, 255, 0), 4: (0, 255, 255),
        5: (0, 0, 255), 6: (255, 0, 255), 7: (255, 255, 255), 8: (128, 128, 128), 9: (192, 192, 192),
    }
    if aci in aci_colors:
        r, g, b = aci_colors[aci]
        color = QColor(r, g, b)
    else:
        if aci == 0 or aci is None:
            color = QColor(0, 0, 0)
        else:
            r = (aci * 37) % 255
            g = (aci * 53) % 255
            b = (aci * 97) % 255
            color = QColor(r, g, b)
    closest_color, closest_index = find_closest_color(color)
    return closest_color, closest_index

class ColorButton(QtWidgets.QPushButton):
    def __init__(self, color, parent=None):
        super().__init__(parent)
        self.color = color
        self.setFixedSize(30, 30)
        self.setStyleSheet(f"background-color: {self.color.name()}; border: 1px solid #adb5bd; border-radius: 6px;")
        self.clicked.connect(self.on_click)

    def on_click(self):
        self.parent().parent.change_selected_items_color(self.color)

class ColorPalette(QtWidgets.QWidget):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.parent = parent
        self.layout = QtWidgets.QHBoxLayout(self)
        self.layout.setSpacing(5)
        self.layout.setContentsMargins(0, 0, 0, 0)
        for color in COLOR_PALETTE:
            button = ColorButton(color, self)
            self.layout.addWidget(button)
        self.layout.addStretch()

class LayerBox(QtWidgets.QWidget):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.parent = parent
        self.layout = QtWidgets.QVBoxLayout(self)
        self.layout.setSpacing(5)
        self.layout.setContentsMargins(0, 0, 0, 0)
        self.layer_label = QtWidgets.QLabel("Layers:")
        self.layout.addWidget(self.layer_label)
        self.layer_list = QtWidgets.QListWidget(self)
        self.layer_list.setMinimumHeight(400)
        self.layer_list.setMaximumHeight(600)
        self.layout.addWidget(self.layer_list)
        self.initialize_layers()

    def initialize_layers(self):
        self.layer_list.clear()
        for i, color in enumerate(COLOR_PALETTE):
            item = QtWidgets.QListWidgetItem()
            widget = QWidget()
            layout = QHBoxLayout(widget)
            layout.setContentsMargins(5, 2, 5, 2)
            checkbox = QCheckBox(f"Layer {i + 1}")
            checkbox.setStyleSheet(f"background-color: white; color: black;")
            checkbox.stateChanged.connect(lambda state, idx=i: self.update_layer_state(idx, state))
            layout.addWidget(checkbox)
            speed_input = QLineEdit("500")
            speed_input.setFixedWidth(60)
            speed_input.setPlaceholderText("Speed")
            speed_input.textChanged.connect(lambda text, idx=i: self.parent.update_layer_settings(idx, "speed", text))
            layout.addWidget(speed_input)
            power_input = QLineEdit("1000")
            power_input.setFixedWidth(60)
            power_input.setPlaceholderText("Power")
            power_input.textChanged.connect(lambda text, idx=i: self.parent.update_layer_settings(idx, "power", text))
            layout.addWidget(power_input)
            layout.addStretch()
            item.setSizeHint(widget.sizeHint())
            self.layer_list.addItem(item)
            self.layer_list.setItemWidget(item, widget)
            item.setData(Qt.UserRole, {"color": color, "used": False, "checked": False})

    def update_layers(self, used_colors):
        for i in range(self.layer_list.count()):
            item = self.layer_list.item(i)
            color = COLOR_PALETTE[i]
            is_used = any(color == used_color for used_color, _ in used_colors)
            data = item.data(Qt.UserRole)
            data["used"] = is_used
            item.setData(Qt.UserRole, data)
            widget = self.layer_list.itemWidget(item)
            checkbox = widget.layout().itemAt(0).widget()
            checkbox.setText(f"Layer {i + 1} {'✅' if is_used else ''}")
            self.update_layer_state(i, checkbox.checkState())

    def update_layer_state(self, index, state):
        item = self.layer_list.item(index)
        data = item.data(Qt.UserRole)
        data["checked"] = state == Qt.Checked
        item.setData(Qt.UserRole, data)
        widget = self.layer_list.itemWidget(item)
        color = data["color"]
        bg_color = color.name() if state == Qt.Checked else "white"
        widget.setStyleSheet(f"background-color: {bg_color};")

class PreviewGraphicsView(QGraphicsView):
    def __init__(self, scene, parent=None):
        super().__init__(scene, parent)
        self.zoom_factor = 1.15
        self.scene().setBackgroundBrush(Qt.black)
        self.setRenderHint(QPainter.Antialiasing)
        self.setViewportUpdateMode(QGraphicsView.FullViewportUpdate)

    def wheelEvent(self, event):
        zoom_in = event.angleDelta().y() > 0
        if zoom_in:
            zoom = self.zoom_factor
        else:
            zoom = 1 / self.zoom_factor
        self.setTransformationAnchor(QGraphicsView.NoAnchor)
        mouse_pos = self.mapToScene(event.pos())
        self.scale(zoom, zoom)
        new_pos = self.mapToScene(event.pos())
        delta = new_pos - mouse_pos
        self.translate(delta.x(), delta.y())

    def fit_to_content(self):
        items = self.scene().items()
        if not items:
            return
        bounding_rect = QRectF()
        for item in items:
            if isinstance(item, (QGraphicsLineItem, QGraphicsEllipseItem)):
                item_rect = item.sceneBoundingRect()
                if bounding_rect.isNull():
                    bounding_rect = item_rect
                else:
                    bounding_rect = bounding_rect.united(item_rect)
        if not bounding_rect.isNull():
            margin = 20
            bounding_rect.adjust(-margin, -margin, margin, margin)
            self.fitInView(bounding_rect, Qt.KeepAspectRatio)
        else:
            self.fitInView(self.scene().sceneRect(), Qt.KeepAspectRatio)

class CustomFileDialog(QFileDialog):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setWindowTitle("Select DXF File")
        self.setNameFilter("DXF Files (*.dxf)")
        self.setFileMode(QFileDialog.ExistingFile)
        self.setOption(QFileDialog.DontUseNativeDialog, True)
        self.resize(1000, 720)
        sidebar_urls = []
        desktop_paths = QStandardPaths.standardLocations(QStandardPaths.DesktopLocation)
        if desktop_paths:
            sidebar_urls.append(QUrl.fromLocalFile(desktop_paths[0]))
        documents_paths = QStandardPaths.standardLocations(QStandardPaths.DocumentsLocation)
        if documents_paths:
            sidebar_urls.append(QUrl.fromLocalFile(documents_paths[0]))
        home_paths = QStandardPaths.standardLocations(QStandardPaths.HomeLocation)
        if home_paths:
            sidebar_urls.append(QUrl.fromLocalFile(home_paths[0]))
        drives = QDir.drives()
        for drive in drives:
            sidebar_urls.append(QUrl.fromLocalFile(drive.absolutePath()))
        self.setSidebarUrls(sidebar_urls)
        self.preview_scene = QGraphicsScene(self)
        self.preview_view = PreviewGraphicsView(self.preview_scene, self)
        self.preview_view.setMinimumSize(400, 400)
        layout = self.layout()
        if layout is None:
            layout = QVBoxLayout()
            self.setLayout(layout)
        splitter = QSplitter(Qt.Horizontal)
        layout.addWidget(splitter)
        splitter.addWidget(self.preview_view)
        splitter.setSizes([600, 400])
        self.currentChanged.connect(self.update_preview)

    def update_preview(self, path):
        self.preview_scene.clear()
        if not path or not os.path.isfile(path) or not path.lower().endswith('.dxf'):
            self.preview_scene.setSceneRect(0, 0, 400, 400)
            self.preview_view.fitInView(self.preview_scene.sceneRect(), Qt.KeepAspectRatio)
            return
        try:
            doc = ezdxf.readfile(path)
            msp = doc.modelspace()
            min_x, min_y = float('inf'), float('inf')
            max_x, max_y = float('-inf'), float('-inf')
            temp_items = []
            for entity in msp:
                color = aci_to_qcolor(entity.dxf.color)[0] if hasattr(entity, 'dxf') and hasattr(entity.dxf, 'color') else QColor(0, 0, 0)
                if entity.dxftype() == "LINE":
                    x1, y1 = entity.dxf.start.x, -entity.dxf.start.y
                    x2, y2 = entity.dxf.end.x, -entity.dxf.end.y
                    min_x, max_x = min(min_x, x1, x2), max(max_x, x1, x2)
                    min_y, max_y = min(min_y, y1, y2), max(max_y, y1, y2)
                    line = QGraphicsLineItem(x1, y1, x2, y2)
                    pen = QPen(color, 0)
                    pen.setCosmetic(True)
                    line.setPen(pen)
                    temp_items.append(line)
                elif entity.dxftype() == "SPLINE":
                    points = entity.fit_points if entity.fit_points else list(entity.flattening(distance=0.01))
                    if len(points) >= 2:
                        is_line = all(abs(point[1] - points[0][1]) < 0.01 for point in points)
                        if is_line:
                            x1, y1 = points[0][0], -points[0][1]
                            x2, y2 = points[-1][0], -points[-1][1]
                            min_x, max_x = min(min_x, x1, x2), max(max_x, x1, x2)
                            min_y, max_y = min(min_y, y1, y2), max(max_y, y1, y2)
                            line = QGraphicsLineItem(x1, y1, x2, y2)
                            pen = QPen(color, 0)
                            pen.setCosmetic(True)
                            line.setPen(pen)
                            temp_items.append(line)
                        else:
                            for i in range(len(points) - 1):
                                x1, y1 = points[i][0], -points[i][1]
                                x2, y2 = points[i + 1][0], -points[i + 1][1]
                                min_x, max_x = min(min_x, x1, x2), max(max_x, x1, x2)
                                min_y, max_y = min(min_y, y1, y2), max(max_y, y1, y2)
                                line = QGraphicsLineItem(x1, y1, x2, y2)
                                pen = QPen(color, 0)
                                pen.setCosmetic(True)
                                line.setPen(pen)
                                temp_items.append(line)
                elif entity.dxftype() == "LWPOLYLINE":
                    points = entity.get_points()
                    if len(points) >= 2:
                        for i in range(len(points) - 1):
                            x1, y1 = points[i][0], -points[i][1]
                            x2, y2 = points[i + 1][0], -points[i + 1][1]
                            min_x, max_x = min(min_x, x1, x2), max(max_x, x1, x2)
                            min_y, max_y = min(min_y, y1, y2), max(max_y, y1, y2)
                            line = QGraphicsLineItem(x1, y1, x2, y2)
                            pen = QPen(color, 0)
                            pen.setCosmetic(True)
                            line.setPen(pen)
                            temp_items.append(line)
                        if entity.closed:
                            x1, y1 = points[-1][0], -points[-1][1]
                            x2, y2 = points[0][0], -points[0][1]
                            min_x, max_x = min(min_x, x1, x2), max(max_x, x1, x2)
                            min_y, max_y = min(min_y, y1, y2), max(max_y, y1, y2)
                            line = QGraphicsLineItem(x1, y1, x2, y2)
                            pen = QPen(color, 0)
                            pen.setCosmetic(True)
                            line.setPen(pen)
                            temp_items.append(line)
                elif entity.dxftype() == "CIRCLE":
                    center_x, center_y = entity.dxf.center.x, -entity.dxf.center.y
                    radius = entity.dxf.radius
                    min_x, max_x = min(min_x, center_x - radius), max(max_x, center_x + radius)
                    min_y, max_y = min(min_y, center_y - radius), max(max_y, center_y + radius)
                    ellipse = QGraphicsEllipseItem(center_x - radius, center_y - radius, 2 * radius, 2 * radius)
                    pen = QPen(color, 0)
                    pen.setCosmetic(True)
                    ellipse.setPen(pen)
                    temp_items.append(ellipse)
                elif entity.dxftype() == "ARC":
                    center_x, center_y = entity.dxf.center.x, -entity.dxf.center.y
                    radius = entity.dxf.radius
                    min_x, max_x = min(min_x, center_x - radius), max(max_x, center_x + radius)
                    min_y, max_y = min(min_y, center_y - radius), max(max_y, center_y + radius)
                    start_angle = math.radians(entity.dxf.start_angle)
                    end_angle = math.radians(entity.dxf.end_angle)
                    if end_angle < start_angle:
                        end_angle += 2 * math.pi
                    num_segments = 36
                    prev_x, prev_y = None, None
                    for i in range(num_segments + 1):
                        t = i / num_segments
                        angle = start_angle + (end_angle - start_angle) * t
                        x = center_x + radius * math.cos(angle)
                        y = center_y + radius * math.sin(angle)
                        if i > 0:
                            line = QGraphicsLineItem(prev_x, prev_y, x, y)
                            pen = QPen(color, 0)
                            pen.setCosmetic(True)
                            line.setPen(pen)
                            temp_items.append(line)
                        prev_x, prev_y = x, y
                elif entity.dxftype() == "ELLIPSE":
                    center_x, center_y = entity.dxf.center.x, -entity.dxf.center.y
                    major_axis = entity.dxf.major_axis
                    ratio = entity.dxf.ratio
                    major_radius = math.sqrt(major_axis[0]**2 + major_axis[1]**2)
                    minor_radius = major_radius * ratio
                    min_x, max_x = min(min_x, center_x - major_radius), max(max_x, center_x + major_radius)
                    min_y, max_y = min(min_y, center_y - minor_radius), max(max_y, center_y + minor_radius)
                    rotation = math.atan2(major_axis[1], major_axis[0])
                    start_angle = entity.dxf.start_angle if hasattr(entity.dxf, 'start_angle') else 0
                    end_angle = entity.dxf.end_angle if hasattr(entity.dxf, 'end_angle') else 2 * math.pi
                    if end_angle < start_angle:
                        end_angle += 2 * math.pi
                    num_segments = 36
                    prev_x, prev_y = None, None
                    for i in range(num_segments + 1):
                        t = i / num_segments
                        angle = start_angle + (end_angle - start_angle) * t
                        x_unrotated = major_radius * math.cos(angle)
                        y_unrotated = minor_radius * math.sin(angle)
                        x = center_x + x_unrotated * math.cos(rotation) - y_unrotated * math.sin(rotation)
                        y = center_y + x_unrotated * math.sin(rotation) + y_unrotated * math.cos(rotation)
                        if i > 0:
                            line = QGraphicsLineItem(prev_x, prev_y, x, y)
                            pen = QPen(color, 0)
                            pen.setCosmetic(True)
                            line.setPen(pen)
                            temp_items.append(line)
                        prev_x, prev_y = x, y
            if min_x != float('inf'):
                center_x = (min_x + max_x) / 2
                center_y = (min_y + max_y) / 2
                offset_x = -center_x
                offset_y = -center_y
                for item in temp_items:
                    if isinstance(item, QGraphicsLineItem):
                        line = item.line()
                        item.setLine(line.x1() + offset_x, line.y1() + offset_y,
                                     line.x2() + offset_x, line.y2() + offset_y)
                    elif isinstance(item, QGraphicsEllipseItem):
                        rect = item.rect()
                        item.setRect(rect.x() + offset_x, rect.y() + offset_y, rect.width(), rect.height())
                    self.preview_scene.addItem(item)
                width = max_x - min_x
                height = max_y - min_y
                margin = 20
                self.preview_scene.setSceneRect(-width/2 - margin, -height/2 - margin,
                                               width + 2 * margin, height + 2 * margin)
                self.preview_view.fitInView(self.preview_scene.sceneRect(), Qt.KeepAspectRatio)
            else:
                self.preview_scene.setSceneRect(0, 0, 400, 400)
                self.preview_view.fitInView(self.preview_scene.sceneRect(), Qt.KeepAspectRatio)
            self.preview_scene.update()
            self.preview_view.viewport().repaint()
        except Exception as e:
            print(f"Error in preview: {str(e)}")
            self.preview_scene.clear()
            self.preview_scene.setSceneRect(0, 0, 400, 400)
            self.preview_view.fitInView(self.preview_scene.sceneRect(), Qt.KeepAspectRatio)

class SelectableGraphicsItem(QGraphicsLineItem):
    def __init__(self, x1, y1, x2, y2, color):
        super().__init__(x1, y1, x2, y2)
        self.setFlags(QGraphicsItem.ItemIsSelectable | QGraphicsItem.ItemIsMovable)
        self.normal_pen = QPen(color, 0)
        self.normal_pen.setCosmetic(True)
        self.setPen(self.normal_pen)
        self.setAcceptHoverEvents(True)

    def shape(self):
        path = QPainterPath()
        path.moveTo(self.line().p1())
        path.lineTo(self.line().p2())
        stroker = QPainterPathStroker()
        stroker.setWidth(5)
        return stroker.createStroke(path)

    def paint(self, painter, option, widget=None):
        painter.setPen(self.normal_pen)
        painter.drawLine(self.line())

    def itemChange(self, change, value):
        if change == QGraphicsItem.ItemSelectedChange:
            self.scene().update()
            if hasattr(self.scene(), 'parent') and hasattr(self.scene().parent(), 'update_selection_bounding_box'):
                self.scene().parent().update_selection_bounding_box()
        return super().itemChange(change, value)

    def set_normal_color(self, color):
        self.normal_pen = QPen(color, 0)
        self.normal_pen.setCosmetic(True)
        self.setPen(self.normal_pen)
        self.update()

class SelectableEllipseItem(QGraphicsEllipseItem):
    def __init__(self, x, y, w, h, color):
        super().__init__(x, y, w, h)
        self.setFlags(QGraphicsItem.ItemIsSelectable | QGraphicsItem.ItemIsMovable)
        self.normal_pen = QPen(color, 0)
        self.normal_pen.setCosmetic(True)
        self.setPen(self.normal_pen)
        self.setAcceptHoverEvents(True)

    def shape(self):
        path = QPainterPath()
        path.addEllipse(self.rect())
        stroker = QPainterPathStroker()
        stroker.setWidth(5)
        return stroker.createStroke(path)

    def paint(self, painter, option, widget=None):
        painter.setPen(self.normal_pen)
        painter.drawEllipse(self.rect())

    def itemChange(self, change, value):
        if change == QGraphicsItem.ItemSelectedChange:
            self.scene().update()
            if hasattr(self.scene(), 'parent') and hasattr(self.scene().parent(), 'update_selection_bounding_box'):
                self.scene().parent().update_selection_bounding_box()
        return super().itemChange(change, value)

    def set_normal_color(self, color):
        self.normal_pen = QPen(color, 0)
        self.normal_pen.setCosmetic(True)
        self.setPen(self.normal_pen)
        self.update()

class SelectableGroup(QGraphicsItemGroup):
    def __init__(self, color):
        super().__init__()
        self.setFlags(QGraphicsItem.ItemIsSelectable | QGraphicsItem.ItemIsMovable)
        self.normal_pen = QPen(color, 0)
        self.normal_pen.setCosmetic(True)
        self.setAcceptHoverEvents(True)

    def shape(self):
        path = QPainterPath()
        for item in self.childItems():
            if isinstance(item, QGraphicsLineItem):
                child_path = QPainterPath()
                child_path.moveTo(item.line().p1())
                child_path.lineTo(item.line().p2())
                path.addPath(child_path)
        stroker = QPainterPathStroker()
        stroker.setWidth(5)
        return stroker.createStroke(path)

    def paint(self, painter, option, widget=None):
        for item in self.childItems():
            if isinstance(item, QGraphicsLineItem):
                painter.setPen(self.normal_pen)
                painter.drawLine(item.line())

    def itemChange(self, change, value):
        if change == QGraphicsItem.ItemSelectedChange:
            self.scene().update()
            if hasattr(self.scene(), 'parent') and hasattr(self.scene().parent(), 'update_selection_bounding_box'):
                self.scene().parent().update_selection_bounding_box()
        return super().itemChange(change, value)

    def set_normal_color(self, color):
        self.normal_pen = QPen(color, 0)
        self.normal_pen.setCosmetic(True)
        for item in self.childItems():
            if isinstance(item, QGraphicsLineItem):
                pen = QPen(color, 0)
                pen.setCosmetic(True)
                item.setPen(pen)
        self.update()

class CustomGraphicsView(QGraphicsView):
    def __init__(self, scene, parent=None):
        super().__init__(scene, parent)
        self.setDragMode(QGraphicsView.RubberBandDrag)
        self.setMouseTracking(True)
        self.zoom_factor = 1.15
        self.is_panning = False
        self.last_pan_point = QPointF()
        self.parent = parent
        self.is_dragging = False
        self.last_drag_pos = QPointF()
        self.initial_positions = {}
        self.rubber_band_rect = None
        self.rubber_band_start = None

    def wheelEvent(self, event):
        mouse_pos = self.mapToScene(event.pos())
        if hasattr(self.parent, 'update_mouse_position'):
            self.parent.update_mouse_position(mouse_pos.x(), mouse_pos.y())
        zoom_in = event.angleDelta().y() > 0
        zoom = self.zoom_factor if zoom_in else 1 / self.zoom_factor
        self.setTransformationAnchor(QGraphicsView.NoAnchor)
        self.scale(zoom, zoom)
        new_pos = self.mapToScene(event.pos())
        delta = new_pos - mouse_pos
        self.translate(delta.x(), delta.y())

    def mousePressEvent(self, event):
        if event.button() == Qt.LeftButton and event.modifiers() == Qt.ControlModifier:
            self.is_panning = True
            self.last_pan_point = self.mapToScene(event.pos())
            self.setCursor(Qt.ClosedHandCursor)
        elif event.button() == Qt.LeftButton:
            scene_pos = self.mapToScene(event.pos())
            items = self.items(event.pos())
            selectable_items = [item for item in items if item.flags() & QGraphicsItem.ItemIsSelectable]
            selected_items = self.scene().selectedItems()
            clicked_on_selected = any(item.boundingRect().translated(item.pos()).contains(scene_pos) for item in selected_items)
            if selectable_items and not clicked_on_selected:
                closest_item = min(selectable_items, key=lambda item: item.boundingRect().width() * item.boundingRect().height(), default=None)
                if closest_item:
                    if not (event.modifiers() & Qt.ShiftModifier):
                        for selected_item in selected_items:
                            selected_item.setSelected(False)
                    closest_item.setSelected(True)
                    self.is_dragging = True
                    self.last_drag_pos = scene_pos
                    self.initial_positions = {item: item.pos() for item in [closest_item] if item.flags() & QGraphicsItem.ItemIsMovable}
            elif clicked_on_selected:
                self.is_dragging = True
                self.last_drag_pos = scene_pos
                self.initial_positions = {item: item.pos() for item in selected_items if item.flags() & QGraphicsItem.ItemIsMovable}
            else:
                if not (event.modifiers() & Qt.ShiftModifier):
                    for selected_item in selected_items:
                        selected_item.setSelected(False)
                self.rubber_band_start = scene_pos
                self.is_dragging = False
                if self.rubber_band_rect:
                    self.scene().removeItem(self.rubber_band_rect)
                self.rubber_band_rect = QGraphicsRectItem()
                pen = QPen(Qt.blue, 0, Qt.DashLine)
                pen.setCosmetic(True)
                self.rubber_band_rect.setPen(pen)
                self.scene().addItem(self.rubber_band_rect)
            self.scene().update()
            self.parent.update_selection_bounding_box()
            self.viewport().update()
        else:
            super().mousePressEvent(event)

    def mouseMoveEvent(self, event):
        mouse_pos = self.mapToScene(event.pos())
        if hasattr(self.parent, 'update_mouse_position'):
            self.parent.update_mouse_position(mouse_pos.x(), mouse_pos.y())
        current_pos = self.mapToScene(event.pos())
        if self.is_panning:
            delta = current_pos - self.last_pan_point
            self.last_pan_point = current_pos
            self.translate(delta.x(), delta.y())
        elif self.is_dragging and hasattr(self, 'last_drag_pos'):
            delta = current_pos - self.last_drag_pos
            self.last_drag_pos = current_pos
            for item in self.scene().selectedItems():
                if item.flags() & QGraphicsItem.ItemIsMovable:
                    item.moveBy(delta.x(), delta.y())
                    item.update()
            self.parent.update_simulation_paths()
            self.parent.update_selection_bounding_box()
        elif self.rubber_band_start is not None:
            min_x = min(self.rubber_band_start.x(), mouse_pos.x())
            min_y = min(self.rubber_band_start.y(), mouse_pos.y())
            max_x = max(self.rubber_band_start.x(), mouse_pos.x())
            max_y = max(self.rubber_band_start.y(), mouse_pos.y())
            self.rubber_band_rect.setRect(min_x, min_y, max_x - min_x, max_y - min_y)
            self.select_items_in_rubber_band(mouse_pos)
        else:
            super().mouseMoveEvent(event)
        self.scene().update()
        self.viewport().update()

    def mouseReleaseEvent(self, event):
        if event.button() == Qt.LeftButton and self.is_panning:
            self.is_panning = False
            self.setCursor(Qt.ArrowCursor)
        elif event.button() == Qt.LeftButton and self.is_dragging:
            self.is_dragging = False
            moved_items = []
            for item in self.scene().selectedItems():
                if item.flags() & QGraphicsItem.ItemIsMovable and item in self.initial_positions:
                    initial_pos = self.initial_positions[item]
                    final_pos = item.pos()
                    if initial_pos != final_pos:
                        moved_items.append((item, initial_pos, final_pos))
            if moved_items:
                self.parent.add_undo_action({"type": "move", "items": moved_items})
            self.initial_positions = {}
            self.parent.update_selection_bounding_box()
            self.parent.update_zero_point()
        elif event.button() == Qt.LeftButton and self.rubber_band_start is not None:
            self.rubber_band_start = None
            if self.rubber_band_rect:
                self.scene().removeItem(self.rubber_band_rect)
                self.rubber_band_rect = None
            self.parent.update_selection_bounding_box()
        else:
            super().mouseReleaseEvent(event)
        self.scene().update()
        self.viewport().update()

    def select_items_in_rubber_band(self, current_pos):
        if self.rubber_band_start is None:
            return
        min_x = min(self.rubber_band_start.x(), current_pos.x())
        min_y = min(self.rubber_band_start.y(), current_pos.y())
        max_x = max(self.rubber_band_start.x(), current_pos.x())
        max_y = max(self.rubber_band_start.y(), current_pos.y())
        rect = QRectF(min_x, min_y, max_x - min_x, max_y - min_y)
        items = self.scene().items(rect, Qt.IntersectsItemShape)
        selectable_items = [item for item in items if item.flags() & QGraphicsItem.ItemIsSelectable]
        if not (QApplication.keyboardModifiers() & Qt.ShiftModifier):
            for item in self.scene().selectedItems():
                if item not in selectable_items:
                    item.setSelected(False)
        for item in selectable_items:
            item.setSelected(True)
        self.scene().update()
        self.parent.update_selection_bounding_box()
        self.viewport().update()

class PositionHelper(QObject):
    def __init__(self, item, parent=None):
        super().__init__(parent)
        self._item = item
        self._pos = item.pos()

    @pyqtProperty(QPointF)
    def pos(self):
        return self._pos

    @pos.setter
    def pos(self, value):
        self._pos = value
        if self._item:
            self._item.setPos(value)

class LaserPreviewWidget(QWidget):
    status_message = pyqtSignal(str)
    highlight_gcode_line = pyqtSignal(int)

    def __init__(self, parent=None):
        super().__init__(parent)
        self.parent = parent
        self.gcode_paths = []
        self.gcode_line_indices = []
        self.line_items = []
        self.speed = 500
        self.worktable_width = 1300
        self.worktable_height = 900
        self.animations = []
        self.current_animation_index = 0
        self.is_paused = False
        self.min_x = 0
        self.max_x = 0
        self.min_y = 0
        self.max_y = 0
        self.laser_head = None
        self.current_position = None
        self.position_helper = None

        self.layout = QVBoxLayout(self)
        self.layout.setSpacing(5)
        self.layout.setContentsMargins(0, 0, 0, 0)

        self.controls_layout = QHBoxLayout()
        self.run_button = QPushButton(self)
        self.run_button.setIcon(self.style().standardIcon(QtWidgets.QStyle.SP_MediaPlay))
        self.run_button.setFixedSize(40, 40)
        self.run_button.clicked.connect(self.run_simulation)
        self.controls_layout.addWidget(self.run_button)

        self.pause_button = QPushButton(self)
        self.pause_button.setIcon(self.style().standardIcon(QtWidgets.QStyle.SP_MediaPause))
        self.pause_button.setFixedSize(40, 40)
        self.pause_button.clicked.connect(self.pause_simulation)
        self.controls_layout.addWidget(self.pause_button)

        self.stop_button = QPushButton(self)
        self.stop_button.setIcon(self.style().standardIcon(QtWidgets.QStyle.SP_MediaStop))
        self.stop_button.setFixedSize(40, 40)
        self.stop_button.clicked.connect(self.stop_simulation)
        self.controls_layout.addWidget(self.stop_button)

        self.speed_label = QLabel("Simulation Speed:")
        self.controls_layout.addWidget(self.speed_label)

        self.speed_slider = QSlider(Qt.Horizontal, self)
        self.speed_slider.setMinimum(1)
        self.speed_slider.setMaximum(1000)
        self.speed_slider.setValue(50)
        self.speed_slider.setFixedWidth(200)
        self.speed_slider.valueChanged.connect(self.update_animation_durations)
        self.controls_layout.addWidget(self.speed_slider)

        self.controls_layout.addStretch()
        self.layout.addLayout(self.controls_layout)

        self.preview_scene = QGraphicsScene(self)
        self.preview_view = QGraphicsView(self.preview_scene, self)
        self.preview_view.setRenderHint(QPainter.Antialiasing)
        self.preview_view.setViewportUpdateMode(QGraphicsView.FullViewportUpdate)
        self.preview_scene.setBackgroundBrush(Qt.black)
        self.preview_view.setMinimumSize(1300, 650)
        self.layout.addWidget(self.preview_view)

        self.blink_timer = QTimer(self)
        self.blink_timer.timeout.connect(self.toggle_button_blink)
        self.blink_state = False
        self.active_button = None

    def parse_gcode(self, gcode_lines):
        paths = []
        self.gcode_line_indices = []
        current_pos = (0, 0)
        laser_on = False
        for i, line in enumerate(gcode_lines):
            line = line.strip()
            if line.startswith(';') or not line:
                continue
            if line == 'M3':
                laser_on = True
                self.gcode_line_indices.append(i)
                continue
            if line == 'M5':
                laser_on = False
                self.gcode_line_indices.append(i)
                continue
            match = re.match(r'G0\s+X([-]?[\d.]+)\s+Y([-]?[\d.]+)', line)
            if match:
                x, y = float(match.group(1)), float(match.group(2))
                paths.append(("move", current_pos, (x, y)))
                self.gcode_line_indices.append(i)
                current_pos = (x, y)
                continue
            match = re.match(r'G1\s+X([-]?[\d.]+)\s+Y([-]?[\d.]+)', line)
            if match and laser_on:
                x, y = float(match.group(1)), float(match.group(2))
                paths.append(("line", current_pos, (x, y)))
                self.gcode_line_indices.append(i)
                current_pos = (x, y)
        return paths

    def set_simulation_data(self, gcode_lines, worktable_width, worktable_height):
        self.gcode_paths = self.parse_gcode(gcode_lines)
        self.worktable_width = worktable_width
        self.worktable_height = worktable_height
        self.draw_paths()

    def draw_paths(self):
        self.preview_scene.clear()
        self.line_items = []
        self.min_x, self.min_y = float('inf'), float('inf')
        self.max_x, self.max_y = float('-inf'), float('-inf')
        valid_paths = []
        valid_indices = []
        
        for i, (segment_type, p1, p2) in enumerate(self.gcode_paths):
            x1, y1 = p1[0], p1[1]
            x2, y2 = p2[0], p2[1]
            if math.isnan(x1) or math.isnan(y1) or math.isnan(x2) or math.isnan(y2):
                continue
            self.min_x = min(self.min_x, x1, x2)
            self.max_x = max(self.max_x, x1, x2)
            self.min_y = min(self.min_y, y1, y2)
            self.max_y = max(self.max_y, y1, y2)
            valid_paths.append((segment_type, p1, p2))
            valid_indices.append(self.gcode_line_indices[i])
        self.gcode_paths = valid_paths
        self.gcode_line_indices = valid_indices
        
        if not self.gcode_paths:
            self.status_message.emit(TRANSLATIONS[self.parent.current_language]["no_gcode_for_simulation"])
            self.preview_scene.setSceneRect(0, 0, 400, 400)
            self.preview_view.fitInView(self.preview_scene.sceneRect(), Qt.KeepAspectRatio)
            return
        
        for segment_type, p1, p2 in self.gcode_paths:
            x1, y1 = p1[0], p1[1]
            x2, y2 = p2[0], p2[1]
            line = QGraphicsLineItem(x1, y1, x2, y2)
            if segment_type == "move":
                pen = QPen(Qt.white, 0, Qt.DashLine)
            else:
                pen = QPen(Qt.white, 0)
            pen.setCosmetic(True)
            line.setPen(pen)
            self.preview_scene.addItem(line)
            self.line_items.append((line, pen.color()))
        
        if self.min_x == float('inf'):
            self.min_x, self.min_y = 0, 0
            self.max_x, self.max_y = self.worktable_width, self.worktable_height
        width = self.max_x - self.min_x
        height = self.max_y - self.min_y
        if width == 0 or height == 0:
            width = self.worktable_width
            height = self.worktable_height
        margin = 20
        bounding_rect = QRectF(self.min_x - margin, self.min_y - margin,
                              width + 2 * margin, height + 2 * margin)
        
        self.preview_scene.setSceneRect(bounding_rect)
        self.fit_view_after_render()
        
        self.preview_scene.update()
        self.preview_view.viewport().repaint()

    def fit_view_after_render(self):
        QTimer.singleShot(50, lambda: self.preview_view.fitInView(self.preview_scene.sceneRect(), Qt.KeepAspectRatio))

    def run_simulation(self):
        if hasattr(self.parent, 'generate_gcode'):
            self.parent.generate_gcode()
        if not self.gcode_paths:
            self.status_message.emit(TRANSLATIONS[self.parent.current_language]["no_gcode_for_simulation"])
            return
        if self.is_paused:
            self.is_paused = False
            if self.current_animation_index < len(self.animations):
                self.animations[self.current_animation_index].start()
                if self.current_animation_index < len(self.gcode_line_indices):
                    self.highlight_gcode_line.emit(self.gcode_line_indices[self.current_animation_index])
            self.set_active_button(self.run_button)
            return
        self.current_animation_index = 0
        self.animations = []
        self.preview_scene.clear()
        self.line_items = []
        self.draw_paths()
        if not self.gcode_paths:
            return
        start_x, start_y = self.gcode_paths[0][1]
        self.laser_head = QGraphicsEllipseItem(-2, -2, 4, 4)
        self.laser_head.setBrush(QBrush(Qt.red))
        self.laser_head.setPen(QPen(Qt.red, 0))
        self.laser_head.setPos(start_x, start_y)
        self.preview_scene.addItem(self.laser_head)
        self.current_position = (start_x, start_y)
        self.position_helper = PositionHelper(self.laser_head, self)
        speed_factor = self.speed_slider.value() / 50.0
        base_duration = 1000 / speed_factor
        for i, (segment_type, p1, p2) in enumerate(self.gcode_paths):
            x1, y1 = p1[0], p1[1]
            x2, y2 = p2[0], p2[1]
            distance = math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2)
            duration = base_duration * (distance / 100) if distance > 0 else base_duration
            animation = QPropertyAnimation(self.position_helper, b"pos")
            animation.setStartValue(QPointF(x1, y1))
            animation.setEndValue(QPointF(x2, y2))
            animation.setDuration(int(duration))
            if i < len(self.gcode_paths) - 1:
                animation.finished.connect(lambda idx=i: self.on_animation_finished(idx))
            else:
                animation.finished.connect(self.on_simulation_completed)
            self.animations.append(animation)
        if self.animations:
            self.animations[0].start()
            self.set_active_button(self.run_button)
            if len(self.gcode_line_indices) > 0:
                self.highlight_gcode_line.emit(self.gcode_line_indices[0])
        self.preview_scene.update()
        self.preview_view.viewport().repaint()

    def pause_simulation(self):
        if not self.is_paused:
            self.is_paused = True
            if self.current_animation_index < len(self.animations):
                self.animations[self.current_animation_index].pause()
            self.set_active_button(self.pause_button)

    def stop_simulation(self):
        self.is_paused = False
        for animation in self.animations:
            animation.stop()
        self.animations = []
        self.current_animation_index = 0
        self.set_active_button(None)
        self.preview_scene.clear()
        self.line_items = []
        self.current_position = None
        self.laser_head = None
        self.position_helper = None
        self.highlight_gcode_line.emit(-1)
        self.draw_paths()

    def update_animation_durations(self):
        speed_factor = self.speed_slider.value() / 50.0
        base_duration = 1000 / speed_factor
        for i, (segment_type, p1, p2) in enumerate(self.gcode_paths):
            x1, y1 = p1[0], p1[1]
            x2, y2 = p2[0], p2[1]
            distance = math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2)
            duration = base_duration * (distance / 100) if distance > 0 else base_duration
            if i < len(self.animations):
                self.animations[i].setDuration(int(duration))

    def on_animation_finished(self, index):
        if index < len(self.line_items):
            line, _ = self.line_items[index]
            segment_type = self.gcode_paths[index][0]
            pen = QPen(Qt.red, 0) if segment_type == "line" else QPen(Qt.white, 0, Qt.DashLine)
            pen.setCosmetic(True)
            line.setPen(pen)
        self.current_animation_index = index + 1
        if self.current_animation_index < len(self.animations) and not self.is_paused:
            self.animations[self.current_animation_index].start()
            if self.current_animation_index < len(self.gcode_line_indices):
                self.highlight_gcode_line.emit(self.gcode_line_indices[self.current_animation_index])
        self.preview_scene.update()
        self.preview_view.viewport().repaint()

    def on_simulation_completed(self):
        self.set_active_button(None)
        self.highlight_gcode_line.emit(-1)
        self.preview_scene.update()
        self.preview_view.viewport().repaint()

    def set_active_button(self, button):
        if self.active_button:
            self.active_button.setStyleSheet("")
        self.active_button = button
        if button:
            self.blink_timer.start(500)
        else:
            self.blink_timer.stop()

    def toggle_button_blink(self):
        if self.active_button:
            self.blink_state = not self.blink_state
            if self.blink_state:
                self.active_button.setStyleSheet("background-color: red; color: white;")
            else:
                self.active_button.setStyleSheet("")
        else:
            self.blink_timer.stop()

class SimulationDialog(QDialog):
    def __init__(self, parent=None, gcode_lines=None, worktable_width=1300, worktable_height=900):
        super().__init__(parent)
        self.current_language = parent.current_language if hasattr(parent, 'current_language') else "English"
        self.setWindowTitle(TRANSLATIONS[self.current_language]["simulation_window"])
        self.setGeometry(100, 100, 1400, 800)
        self.setModal(True)
        self.layout = QGridLayout(self)
        self.laser_preview_widget = LaserPreviewWidget(self)
        self.laser_preview_widget.preview_view.setMinimumSize(1300, 650)
        self.layout.addWidget(self.laser_preview_widget, 0, 0, 3, 1)
        self.laser_preview_widget.set_simulation_data(gcode_lines, worktable_width, worktable_height)
        self.laser_preview_widget.status_message.connect(self.parent().update_status_label)
        self.laser_preview_widget.highlight_gcode_line.connect(self.highlight_gcode_line)

        self.gcode_display_label = QLabel(TRANSLATIONS[self.current_language]["gcode_display_label"])
        self.layout.addWidget(self.gcode_display_label, 1, 1)
        self.gcode_display = QTextEdit(self)
        self.gcode_display.setReadOnly(True)
        self.gcode_display.setFixedSize(300, 150)
        self.gcode_display.setStyleSheet("background-color: #f0f0f0; font-family: monospace;")
        if gcode_lines:
            self.gcode_display.setText("\n".join(gcode_lines))
        self.layout.addWidget(self.gcode_display, 2, 1)

    def highlight_gcode_line(self, line_index):
        selections = []
        if line_index >= 0:
            cursor = self.gcode_display.textCursor()
            cursor.movePosition(QTextCursor.Start)
            for i in range(line_index):
                cursor.movePosition(QTextCursor.Down)
            cursor.movePosition(QTextCursor.StartOfLine)
            cursor.movePosition(QTextCursor.EndOfLine, QTextCursor.KeepAnchor)
            format = QTextCharFormat()
            format.setBackground(QColor("yellow"))
            selection = QTextEdit.ExtraSelection()
            selection.cursor = cursor
            selection.format = format
            selections.append(selection)
            self.gcode_display.setTextCursor(cursor)
            self.gcode_display.ensureCursorVisible()
        self.gcode_display.setExtraSelections(selections)

class TableConfigDialog(QDialog):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.current_language = parent.current_language if hasattr(parent, 'current_language') else "English"
        self.setWindowTitle(TRANSLATIONS[self.current_language]["table_config_action"])
        self.setGeometry(200, 200, 400, 250)
        self.layout = QVBoxLayout(self)
        self.profile_label = QLabel(TRANSLATIONS[self.current_language]["table_profile_label"], self)
        self.layout.addWidget(self.profile_label)
        self.profile_combo = QComboBox(self)
        self.profile_combo.addItems(["Default", "Custom Device 1", "Custom Device 2"])
        self.layout.addWidget(self.profile_combo)
        self.width_label = QLabel(TRANSLATIONS[self.current_language]["table_width_label"], self)
        self.layout.addWidget(self.width_label)
        self.width_input = QLineEdit(str(parent.worktable_width), self)
        self.layout.addWidget(self.width_input)
        self.height_label = QLabel(TRANSLATIONS[self.current_language]["table_height_label"], self)
        self.layout.addWidget(self.height_label)
        self.height_input = QLineEdit(str(parent.worktable_height), self)
        self.layout.addWidget(self.height_input)
        self.button_box = QDialogButtonBox(QDialogButtonBox.Save | QDialogButtonBox.Cancel)
        self.button_box.accepted.connect(self.save_settings)
        self.button_box.rejected.connect(self.reject)
        self.layout.addWidget(self.button_box)
        self.parent = parent

    def save_settings(self):
        try:
            new_width = float(self.width_input.text())
            new_height = float(self.height_input.text())
            if new_width > 0 and new_height > 0:
                self.parent.worktable_width = new_width
                self.parent.worktable_height = new_height
                self.parent.view.setSceneRect(0, 0, new_width, new_height)
                self.parent.scene.clear()
                self.parent.draw_worktable()
                for path, item in self.parent.graphics_items:
                    self.parent.scene.addItem(item)
                self.parent.view.fitInView(0, 0, new_width, new_height, Qt.KeepAspectRatio)
                self.parent.label.setText(TRANSLATIONS[self.current_language]["table_size_updated"])
                settings = {
                    "table_width": new_width,
                    "table_height": new_height,
                    "profile": self.profile_combo.currentText(),
                    "zero_point_corner": self.parent.zero_point_corner,
                    "language": self.parent.current_language
                }
                with open("settings.json", "w") as f:
                    json.dump(settings, f)
                self.parent.update_zero_point()
                self.accept()
            else:
                self.parent.label.setText(TRANSLATIONS[self.current_language]["table_dimensions_positive"])
        except ValueError:
            self.parent.label.setText(TRANSLATIONS[self.current_language]["invalid_table_dimensions"])

class CNCApp(QtWidgets.QMainWindow):
    def __init__(self):
        super().__init__()
        self.current_language = "English"
        self.layer_settings = {i: {"speed": "500", "power": "1000"} for i in range(len(COLOR_PALETTE))}
        if os.path.exists("settings.json"):
            try:
                with open("settings.json", "r") as f:
                    settings = json.load(f)
                    self.current_language = settings.get("language", "English")
            except Exception as e:
                self.current_language = "English"
        self.setWindowTitle("CNCSoft")
        self.setGeometry(100, 100, 1700, 900)
        self.paths = []
        self.graphics_items = []
        self.used_colors = []
        self.bounding_min_x = 0
        self.bounding_min_y = 0
        self.bounding_max_x = 0
        self.bounding_max_y = 0
        self.undo_stack = []
        self.redo_stack = []
        self.max_undo_steps = 50
        self.gcode_lines = []
        self.selection_bounding_box = None
        self.zero_point = QPointF(0, 0)
        self.zero_point_corner = "top_left"
        self.zero_point_marker = None

        self.central_widget = QWidget(self)
        self.setCentralWidget(self.central_widget)
        self.main_layout = QHBoxLayout(self.central_widget)

        self.left_layout = QVBoxLayout()
        self.main_layout.addLayout(self.left_layout)

        self.menu_bar = self.menuBar()
        self.file_menu = self.menu_bar.addMenu(TRANSLATIONS[self.current_language]["file_menu"])
        self.import_action = QtWidgets.QAction(TRANSLATIONS[self.current_language]["import_action"], self)
        self.import_action.triggered.connect(self.open_dxf)
        self.file_menu.addAction(self.import_action)
        self.edit_menu = self.menu_bar.addMenu(TRANSLATIONS[self.current_language]["edit_menu"])
        self.config_menu = self.menu_bar.addMenu(TRANSLATIONS[self.current_language]["config_menu"])
        self.help_menu = self.menu_bar.addMenu(TRANSLATIONS[self.current_language]["help_menu"])
        self.language_menu = self.menu_bar.addMenu(TRANSLATIONS[self.current_language]["language_menu"])
        self.english_action = QtWidgets.QAction(TRANSLATIONS[self.current_language]["english_action"], self)
        self.english_action.triggered.connect(lambda: self.update_language("English"))
        self.language_menu.addAction(self.english_action)
        self.persian_action = QtWidgets.QAction(TRANSLATIONS[self.current_language]["persian_action"], self)
        self.persian_action.triggered.connect(lambda: self.update_language("Persian"))
        self.language_menu.addAction(self.persian_action)
        self.table_config_action = QtWidgets.QAction(TRANSLATIONS[self.current_language]["table_config_action"], self)
        self.table_config_action.triggered.connect(self.open_table_config)
        self.config_menu.addAction(self.table_config_action)

        button_style = """
            QPushButton {
                background-color: #e8ecef;
                border: 1px solid #adb5bd;
                padding: 6px;
                border-radius: 6px;
                font-size: 12px;
            }
            QPushButton:hover {
                background-color: #dee2e6;
            }
            QPushButton:pressed {
                background-color: #ced4da;
                border: 1px solid #6c757d;
            }
        """

        zero_button_style = """
            QPushButton {
                background-color: white;
                border: 1px solid #adb5bd;
                border-radius: 4px;
            }
            QPushButton:checked {
                background-color: black;
            }
        """

        self.button_layout = QHBoxLayout()
        self.button_gcode = QtWidgets.QPushButton(TRANSLATIONS[self.current_language]["generate_gcode"], self)
        self.button_gcode.setFixedSize(150, 30)
        self.button_gcode.clicked.connect(self.generate_gcode)
        self.button_gcode.setEnabled(False)
        self.button_gcode.setStyleSheet(button_style)
        self.button_layout.addWidget(self.button_gcode)

        self.button_delete = QtWidgets.QPushButton(TRANSLATIONS[self.current_language]["delete_selected"], self)
        self.button_delete.setFixedSize(150, 30)
        self.button_delete.setIcon(self.style().standardIcon(QtWidgets.QStyle.SP_TrashIcon))
        self.button_delete.clicked.connect(self.delete_selected_items)
        self.button_delete.setStyleSheet(button_style)
        self.button_layout.addWidget(self.button_delete)

        self.button_undo = QtWidgets.QPushButton(TRANSLATIONS[self.current_language]["undo"], self)
        self.button_undo.setFixedSize(100, 30)
        self.button_undo.setIcon(self.style().standardIcon(QtWidgets.QStyle.SP_ArrowBack))
        self.button_undo.clicked.connect(self.undo)
        self.button_undo.setStyleSheet(button_style)
        self.button_layout.addWidget(self.button_undo)

        self.button_redo = QtWidgets.QPushButton(TRANSLATIONS[self.current_language]["redo"], self)
        self.button_redo.setFixedSize(100, 30)
        self.button_redo.setIcon(self.style().standardIcon(QtWidgets.QStyle.SP_ArrowForward))
        self.button_redo.clicked.connect(self.redo)
        self.button_redo.setStyleSheet(button_style)
        self.button_layout.addWidget(self.button_redo)

        self.zero_buttons_layout = QGridLayout()
        self.zero_buttons_layout.setSpacing(5)
        self.zero_button_group = QButtonGroup(self)
        self.zero_button_group.setExclusive(True)

        self.zero_button_top_left = QPushButton(self)
        self.zero_button_top_left.setFixedSize(20, 20)
        self.zero_button_top_left.setCheckable(True)
        self.zero_button_top_left.setStyleSheet(zero_button_style)
        self.zero_button_top_left.clicked.connect(lambda: self.set_zero_point_corner("top_left"))
        self.zero_buttons_layout.addWidget(self.zero_button_top_left, 0, 0)
        self.zero_button_group.addButton(self.zero_button_top_left)

        self.zero_button_top_right = QPushButton(self)
        self.zero_button_top_right.setFixedSize(20, 20)
        self.zero_button_top_right.setCheckable(True)
        self.zero_button_top_right.setStyleSheet(zero_button_style)
        self.zero_button_top_right.clicked.connect(lambda: self.set_zero_point_corner("top_right"))
        self.zero_buttons_layout.addWidget(self.zero_button_top_right, 0, 1)
        self.zero_button_group.addButton(self.zero_button_top_right)

        self.zero_button_bottom_left = QPushButton(self)
        self.zero_button_bottom_left.setFixedSize(20, 20)
        self.zero_button_bottom_left.setCheckable(True)
        self.zero_button_bottom_left.setStyleSheet(zero_button_style)
        self.zero_button_bottom_left.clicked.connect(lambda: self.set_zero_point_corner("bottom_left"))
        self.zero_buttons_layout.addWidget(self.zero_button_bottom_left, 1, 0)
        self.zero_button_group.addButton(self.zero_button_bottom_left)

        self.zero_button_bottom_right = QPushButton(self)
        self.zero_button_bottom_right.setFixedSize(20, 20)
        self.zero_button_bottom_right.setCheckable(True)
        self.zero_button_bottom_right.setStyleSheet(zero_button_style)
        self.zero_button_bottom_right.clicked.connect(lambda: self.set_zero_point_corner("bottom_right"))
        self.zero_buttons_layout.addWidget(self.zero_button_bottom_right, 1, 1)
        self.zero_button_group.addButton(self.zero_button_bottom_right)

        self.button_simulation = QPushButton(self)
        self.button_simulation.setFixedSize(30, 30)
        self.button_simulation.setIcon(self.style().standardIcon(QtWidgets.QStyle.SP_ComputerIcon))
        self.button_simulation.clicked.connect(self.open_simulation_window)
        self.button_simulation.setStyleSheet(button_style)
        self.button_layout.addWidget(self.button_simulation)

        self.button_layout.addLayout(self.zero_buttons_layout)
        self.button_layout.addStretch()

        self.left_layout.addLayout(self.button_layout)

        self.input_layout = QHBoxLayout()
        self.label_speed = QLabel(TRANSLATIONS[self.current_language]["speed_label"], self)
        self.input_layout.addWidget(self.label_speed)
        self.input_speed = QLineEdit("500", self)
        self.input_speed.setFixedWidth(60)
        self.input_layout.addWidget(self.input_speed)
        self.label_power = QLabel(TRANSLATIONS[self.current_language]["power_label"], self)
        self.input_layout.addWidget(self.label_power)
        self.input_power = QLineEdit("1000", self)
        self.input_power.setFixedWidth(60)
        self.input_layout.addWidget(self.input_power)
        self.input_layout.addStretch()
        self.left_layout.addLayout(self.input_layout)

        self.label = QtWidgets.QLabel(TRANSLATIONS[self.current_language]["no_file_selected"], self)
        self.left_layout.addWidget(self.label)

        self.mouse_layout = QHBoxLayout()
        self.label_mouse_x = QLabel(TRANSLATIONS[self.current_language]["mouse_x_label"], self)
        self.mouse_layout.addWidget(self.label_mouse_x)
        self.input_mouse_x = QLineEdit("0", self)
        self.input_mouse_x.setFixedWidth(60)
        self.input_mouse_x.setReadOnly(True)
        self.mouse_layout.addWidget(self.input_mouse_x)
        self.label_mouse_y = QLabel(TRANSLATIONS[self.current_language]["mouse_y_label"], self)
        self.mouse_layout.addWidget(self.label_mouse_y)
        self.input_mouse_y = QLineEdit("0", self)
        self.input_mouse_y.setFixedWidth(60)
        self.input_mouse_y.setReadOnly(True)
        self.mouse_layout.addWidget(self.input_mouse_y)
        self.mouse_layout.addStretch()
        self.left_layout.addLayout(self.mouse_layout)

        self.scene = QGraphicsScene(self)
        self.scene.setBackgroundBrush(QBrush(QColor(240, 240, 240)))
        self.scene.setParent(self)
        self.view = CustomGraphicsView(self.scene, self)
        self.view.setMinimumSize(1276, 748)
        self.left_layout.addWidget(self.view)

        self.right_layout = QVBoxLayout()
        self.main_layout.addLayout(self.right_layout)

        self.color_palette = ColorPalette(self)
        self.right_layout.addWidget(self.color_palette)

        self.splitter = QSplitter(Qt.Vertical)
        self.layer_box = LayerBox(self)
        self.splitter.addWidget(self.layer_box)
        self.right_layout.addWidget(self.splitter)

        self.right_layout.addStretch()

        self.worktable_width = 1300
        self.worktable_height = 900
        if os.path.exists("settings.json"):
            try:
                with open("settings.json", "r") as f:
                    settings = json.load(f)
                    self.worktable_width = settings.get("table_width", 1300)
                    self.worktable_height = settings.get("table_height", 900)
                    self.zero_point_corner = settings.get("zero_point_corner", "top_left")
            except Exception as e:
                self.label.setText(TRANSLATIONS[self.current_language]["error_loading_settings"].format(error=str(e)))

        if self.zero_point_corner == "top_left":
            self.zero_button_top_left.setChecked(True)
        elif self.zero_point_corner == "top_right":
            self.zero_button_top_right.setChecked(True)
        elif self.zero_point_corner == "bottom_left":
            self.zero_button_bottom_left.setChecked(True)
        elif self.zero_point_corner == "bottom_right":
            self.zero_button_bottom_right.setChecked(True)

        self.view.setSceneRect(0, 0, self.worktable_width, self.worktable_height)
        self.draw_worktable()
        self.update_zero_point()
        self.update_language(self.current_language)

        self.shortcut_select_all = QShortcut(QKeySequence("Ctrl+A"), self)
        self.shortcut_select_all.activated.connect(self.select_all_items)
        self.shortcut_delete = QShortcut(QKeySequence("Delete"), self)
        self.shortcut_delete.activated.connect(self.delete_selected_items)
        self.shortcut_undo = QShortcut(QKeySequence("Ctrl+Z"), self)
        self.shortcut_undo.activated.connect(self.undo)
        self.shortcut_redo = QShortcut(QKeySequence("Ctrl+Y"), self)
        self.shortcut_redo.activated.connect(self.redo)

    def update_language(self, language):
        self.current_language = language
        self.file_menu.setTitle(TRANSLATIONS[language]["file_menu"])
        self.import_action.setText(TRANSLATIONS[language]["import_action"])
        self.edit_menu.setTitle(TRANSLATIONS[language]["edit_menu"])
        self.config_menu.setTitle(TRANSLATIONS[language]["config_menu"])
        self.help_menu.setTitle(TRANSLATIONS[language]["help_menu"])
        self.language_menu.setTitle(TRANSLATIONS[language]["language_menu"])
        self.english_action.setText(TRANSLATIONS[language]["english_action"])
        self.persian_action.setText(TRANSLATIONS[language]["persian_action"])
        self.table_config_action.setText(TRANSLATIONS[language]["table_config_action"])
        self.button_gcode.setText(TRANSLATIONS[language]["generate_gcode"])
        self.button_delete.setText(TRANSLATIONS[language]["delete_selected"])
        self.button_undo.setText(TRANSLATIONS[language]["undo"])
        self.button_redo.setText(TRANSLATIONS[language]["redo"])
        self.label_speed.setText(TRANSLATIONS[language]["speed_label"])
        self.label_power.setText(TRANSLATIONS[language]["power_label"])
        self.label_mouse_x.setText(TRANSLATIONS[language]["mouse_x_label"])
        self.label_mouse_y.setText(TRANSLATIONS[language]["mouse_y_label"])
        self.label.setText(TRANSLATIONS[language]["no_file_selected"])
        self.layer_box.layer_label.setText("لایه‌ها:" if language == "Persian" else "Layers:")
        self.scene.update()
        self.view.viewport().update()
        try:
            settings = {
                "table_width": self.worktable_width,
                "table_height": self.worktable_height,
                "profile": "Default",
                "zero_point_corner": self.zero_point_corner,
                "language": self.current_language
            }
            with open("settings.json", "w") as f:
                json.dump(settings, f)
            language_name = "فارسی" if language == "Persian" else "English"
            self.label.setText(TRANSLATIONS[self.current_language]["language_saved"].format(language=language_name))
        except Exception as e:
            self.label.setText(TRANSLATIONS[self.current_language]["error_saving_language"].format(error=str(e)))

    def update_layer_settings(self, layer_index, setting_type, value):
        self.layer_settings[layer_index][setting_type] = value

    def update_status_label(self, message):
        self.label.setText(message)

    def open_simulation_window(self):
        if not self.gcode_lines:
            self.generate_gcode()
        if not self.gcode_lines:
            self.label.setText(TRANSLATIONS[self.current_language]["no_gcode_for_simulation"])
            return
        dialog = SimulationDialog(self, self.gcode_lines, self.worktable_width, self.worktable_height)
        dialog.exec_()

    def calculate_objects_bounding_box(self):
        min_x, min_y = float('inf'), float('inf')
        max_x, max_y = float('-inf'), float('-inf')
        for _, item in self.graphics_items:
            rect = item.boundingRect().translated(item.pos())
            min_x = min(min_x, rect.left())
            min_y = min(min_y, rect.top())
            max_x = max(max_x, rect.right())
            max_y = max(max_y, rect.bottom())
        if min_x == float('inf'):
            return 0, 0, self.worktable_width, self.worktable_height
        return min_x, min_y, max_x, max_y

    def set_zero_point_corner(self, corner):
        corner_translations = {
            "top_left": "بالا چپ" if self.current_language == "Persian" else "top left",
            "top_right": "بالا راست" if self.current_language == "Persian" else "top right",
            "bottom_left": "پایین چپ" if self.current_language == "Persian" else "bottom left",
            "bottom_right": "پایین راست" if self.current_language == "Persian" else "bottom right"
        }
        self.zero_point_corner = corner
        self.update_zero_point()
        if self.paths:
            self.generate_gcode()
        self.label.setText(TRANSLATIONS[self.current_language]["zero_point_set"].format(corner=corner_translations[corner]))
        settings = {
            "table_width": self.worktable_width,
            "table_height": self.worktable_height,
            "profile": "Default",
            "zero_point_corner": self.zero_point_corner,
            "language": self.current_language
        }
        try:
            with open("settings.json", "w") as f:
                json.dump(settings, f)
        except Exception as e:
            self.label.setText(TRANSLATIONS[self.current_language]["error_saving_zero_point"].format(error=str(e)))

    def update_zero_point(self):
        if self.zero_point_marker and self.zero_point_marker.scene() == self.scene:
            self.scene.removeItem(self.zero_point_marker)
        self.zero_point_marker = None
        min_x, min_y, max_x, max_y = self.calculate_objects_bounding_box()
        if self.zero_point_corner == "top_left":
            self.zero_point = QPointF(min_x, min_y)
        elif self.zero_point_corner == "top_right":
            self.zero_point = QPointF(max_x, min_y)
        elif self.zero_point_corner == "bottom_left":
            self.zero_point = QPointF(min_x, max_y)
        else:
            self.zero_point = QPointF(max_x, max_y)
        marker_size = 5
        self.zero_point_marker = QGraphicsEllipseItem(
            self.zero_point.x() - marker_size / 2,
            self.zero_point.y() - marker_size / 2,
            marker_size, marker_size
        )
        self.zero_point_marker.setBrush(QBrush(Qt.red))
        self.zero_point_marker.setPen(QPen(Qt.red, 0))
        self.zero_point_marker.setZValue(100)
        self.scene.addItem(self.zero_point_marker)
        self.scene.update()
        self.view.viewport().update()

    def update_selection_bounding_box(self):
        if self.selection_bounding_box:
            self.scene.removeItem(self.selection_bounding_box)
            self.selection_bounding_box = None
        selected_items = self.scene.selectedItems()
        if not selected_items:
            self.scene.update()
            self.view.viewport().update()
            return
        min_x, min_y = float('inf'), float('inf')
        max_x, max_y = float('-inf'), float('-inf')
        for item in selected_items:
            rect = item.boundingRect().translated(item.pos())
            min_x = min(min_x, rect.left())
            min_y = min(min_y, rect.top())
            max_x = max(max_x, rect.right())
            max_y = max(max_y, rect.bottom())
        self.selection_bounding_box = QGraphicsRectItem(min_x - 2, min_y - 2, max_x - min_x + 4, max_y - min_y + 4)
        pen = QPen(Qt.red, 0, Qt.DashLine)
        pen.setCosmetic(True)
        self.selection_bounding_box.setPen(pen)
        self.scene.addItem(self.selection_bounding_box)
        self.scene.update()
        self.view.viewport().update()

    def add_undo_action(self, action):
        self.undo_stack.append(action)
        if len(self.undo_stack) > self.max_undo_steps:
            self.undo_stack.pop(0)
        self.redo_stack.clear()

    def select_all_items(self):
        for item in self.scene.items():
            if isinstance(item, (SelectableGraphicsItem, SelectableEllipseItem, SelectableGroup)):
                item.setSelected(True)
        self.update_selection_bounding_box()
        self.label.setText(TRANSLATIONS[self.current_language]["all_items_selected"])
        self.update_simulation_paths()

    def delete_selected_items(self):
        selected_items = self.scene.selectedItems()
        if not selected_items:
            self.label.setText(TRANSLATIONS[self.current_language]["no_items_to_delete"])
            return
        deleted_items = []
        for item in selected_items:
            if isinstance(item, (SelectableGraphicsItem, SelectableEllipseItem, SelectableGroup)):
                for path, graphics_item in self.graphics_items:
                    if graphics_item == item:
                        deleted_items.append((path, graphics_item))
                        self.paths.remove(path)
                        self.graphics_items.remove((path, graphics_item))
                        break
                self.scene.removeItem(item)
        if deleted_items:
            self.add_undo_action({"type": "delete", "items": deleted_items})
            self.update_used_colors()
            self.label.setText(TRANSLATIONS[self.current_language]["deleted_items"].format(count=len(deleted_items)))
            self.update_simulation_paths()
            self.update_zero_point()
        else:
            self.label.setText(TRANSLATIONS[self.current_language]["no_valid_items_to_delete"])
        self.update_selection_bounding_box()
        self.scene.update()
        self.view.viewport().update()

    def undo(self):
        if not self.undo_stack:
            self.label.setText(TRANSLATIONS[self.current_language]["nothing_to_undo"])
            return
        action = self.undo_stack.pop()
        if action["type"] == "delete":
            deleted_items = action["items"]
            for path, item in deleted_items:
                self.paths.append(path)
                self.graphics_items.append((path, item))
                self.scene.addItem(item)
            self.redo_stack.append(action)
            self.update_used_colors()
            self.label.setText(TRANSLATIONS[self.current_language]["restored_items"].format(count=len(deleted_items)))
            self.update_simulation_paths()
            self.update_zero_point()
        elif action["type"] == "move":
            moved_items = action["items"]
            for item, initial_pos, final_pos in moved_items:
                item.setPos(initial_pos)
                item.update()
            self.redo_stack.append(action)
            self.label.setText(TRANSLATIONS[self.current_language]["undid_move"].format(count=len(moved_items)))
            self.update_simulation_paths()
            self.update_zero_point()
        elif action["type"] == "color_change":
            changed_items = action["items"]
            for item, old_color, _ in changed_items:
                item.set_normal_color(old_color)
            self.redo_stack.append(action)
            self.update_used_colors()
            self.label.setText(TRANSLATIONS[self.current_language]["undid_color_change"].format(count=len(changed_items)))
            self.update_simulation_paths()
        self.update_selection_bounding_box()
        self.scene.update()
        self.view.viewport().update()

    def redo(self):
        if not self.redo_stack:
            self.label.setText(TRANSLATIONS[self.current_language]["nothing_to_redo"])
            return
        action = self.redo_stack.pop()
        if action["type"] == "delete":
            deleted_items = action["items"]
            for path, item in deleted_items:
                self.paths.remove(path)
                self.graphics_items.remove((path, item))
                self.scene.removeItem(item)
            self.undo_stack.append(action)
            self.update_used_colors()
            self.label.setText(TRANSLATIONS[self.current_language]["redeleted_items"].format(count=len(deleted_items)))
            self.update_simulation_paths()
            self.update_zero_point()
        elif action["type"] == "move":
            moved_items = action["items"]
            for item, initial_pos, final_pos in moved_items:
                item.setPos(final_pos)
                item.update()
            self.undo_stack.append(action)
            self.label.setText(TRANSLATIONS[self.current_language]["redid_move"].format(count=len(moved_items)))
            self.update_simulation_paths()
            self.update_zero_point()
        elif action["type"] == "color_change":
            changed_items = action["items"]
            for item, _, new_color in changed_items:
                item.set_normal_color(new_color)
            self.undo_stack.append(action)
            self.update_used_colors()
            self.label.setText(TRANSLATIONS[self.current_language]["redid_color_change"].format(count=len(changed_items)))
            self.update_simulation_paths()
        self.update_selection_bounding_box()
        self.scene.update()
        self.view.viewport().update()

    def update_used_colors(self):
        self.used_colors = []
        for item in self.scene.items():
            if isinstance(item, (SelectableGraphicsItem, SelectableEllipseItem, SelectableGroup)):
                color = item.normal_pen.color()
                _, color_index = find_closest_color(color)
                if (color, color_index) not in self.used_colors:
                    self.used_colors.append((color, color_index))
        self.used_colors.sort(key=lambda x: x[1])
        self.layer_box.update_layers(self.used_colors)

    def open_table_config(self):
        dialog = TableConfigDialog(self)
        dialog.exec_()

    def change_selected_items_color(self, new_color):
        selected_items = self.scene.selectedItems()
        if not selected_items:
            self.label.setText(TRANSLATIONS[self.current_language]["no_items_to_change_color"])
            return
        _, new_color_index = find_closest_color(new_color)
        changed_items = []
        for item in selected_items:
            if isinstance(item, (SelectableGraphicsItem, SelectableEllipseItem, SelectableGroup)):
                old_color = item.normal_pen.color()
                changed_items.append((item, old_color, new_color))
                item.set_normal_color(new_color)
        if changed_items:
            self.add_undo_action({"type": "color_change", "items": changed_items})
        self.update_used_colors()
        self.label.setText(TRANSLATIONS[self.current_language]["color_changed"].format(count=len(selected_items)))
        self.update_selection_bounding_box()
        self.scene.update()
        self.view.viewport().update()

    def update_mouse_position(self, x, y):
        self.input_mouse_x.setText(f"{x:.2f}")
        self.input_mouse_y.setText(f"{y:.2f}")

    def draw_worktable(self):
        grid_step = 100
        for x in range(0, int(self.worktable_width) + 1, grid_step):
            line = QGraphicsLineItem(x, 0, x, self.worktable_height)
            line.setPen(Qt.lightGray)
            self.scene.addItem(line)
            label = QGraphicsTextItem(str(x))
            label.setPos(x - 10, self.worktable_height - 20)
            self.scene.addItem(label)
        for y in range(0, int(self.worktable_height) + 1, grid_step):
            line = QGraphicsLineItem(0, y, self.worktable_width, y)
            line.setPen(Qt.lightGray)
            self.scene.addItem(line)
            label = QGraphicsTextItem(str(self.worktable_height - y))
            label.setPos(-30, y - 5)
            self.scene.addItem(label)
        border = QGraphicsLineItem(0, 0, self.worktable_width, 0)
        border.setPen(Qt.black)
        self.scene.addItem(border)
        border = QGraphicsLineItem(0, self.worktable_height, self.worktable_width, self.worktable_height)
        border.setPen(Qt.black)
        self.scene.addItem(border)
        border = QGraphicsLineItem(0, 0, 0, self.worktable_height)
        border.setPen(Qt.black)
        self.scene.addItem(border)
        border = QGraphicsLineItem(self.worktable_width, 0, self.worktable_width, self.worktable_height)
        border.setPen(Qt.black)
        self.scene.addItem(border)

    def open_dxf(self):
        dialog = CustomFileDialog(self)
        if dialog.exec_():
            file_path = dialog.selectedFiles()[0]
            try:
                doc = ezdxf.readfile(file_path)
                msp = doc.modelspace()
                self.paths = []
                self.graphics_items = []
                self.used_colors = []
                self.undo_stack = []
                self.redo_stack = []
                self.gcode_lines = []
                self.scene.clear()
                self.zero_point_marker = None
                self.draw_worktable()
                min_x, min_y = float('inf'), float('inf')
                max_x, max_y = float('-inf'), float('-inf')
                temp_paths = []
                temp_items = []
                for entity in msp:
                    color = None
                    if hasattr(entity, 'dxf') and hasattr(entity.dxf, 'color'):
                        color, _ = aci_to_qcolor(entity.dxf.color)
                    if color is None and hasattr(entity, 'dxf') and hasattr(entity.dxf, 'layer'):
                        layer_name = entity.dxf.layer
                        layer = doc.layers.get(layer_name)
                        if layer and hasattr(layer, 'color'):
                            color, _ = aci_to_qcolor(layer.color)
                    if color is None:
                        color = QColor(0, 0, 0)
                    color_index = find_closest_color(color)[1]
                    if (color, color_index) not in self.used_colors:
                        self.used_colors.append((color, color_index))
                    if entity.dxftype() == "LINE":
                        x1, y1 = entity.dxf.start.x, -entity.dxf.start.y
                        x2, y2 = entity.dxf.end.x, -entity.dxf.end.y
                        min_x, max_x = min(min_x, x1, x2), max(max_x, x1, x2)
                        min_y, max_y = min(min_y, y1, y2), max(max_y, y1, y2)
                        path = [("line", (x1, y1), (x2, y2))]
                        line = SelectableGraphicsItem(x1, y1, x2, y2, color)
                        temp_paths.append(path)
                        temp_items.append((path, line))
                    elif entity.dxftype() == "SPLINE":
                        points = entity.fit_points if entity.fit_points else list(entity.flattening(distance=0.01))
                        if len(points) >= 2:
                            is_line = all(abs(point[1] - points[0][1]) < 0.01 for point in points)
                            path = []
                            group = SelectableGroup(color)
                            if is_line:
                                x1, y1 = points[0][0], -points[0][1]
                                x2, y2 = points[-1][0], -points[-1][1]
                                min_x, max_x = min(min_x, x1, x2), max(max_x, x1, x2)
                                min_y, max_y = min(min_y, y1, y2), max(max_y, y1, y2)
                                path = [("line", (x1, y1), (x2, y2))]
                                line = QGraphicsLineItem(x1, y1, x2, y2)
                                pen = QPen(color, 0)
                                pen.setCosmetic(True)
                                line.setPen(pen)
                                group.addToGroup(line)
                            else:
                                for i in range(len(points) - 1):
                                    x1, y1 = points[i][0], -points[i][1]
                                    x2, y2 = points[i + 1][0], -points[i + 1][1]
                                    min_x, max_x = min(min_x, x1, x2), max(max_x, x1, x2)
                                    min_y, max_y = min(min_y, y1, y2), max(max_y, y1, y2)
                                    path.append(("line", (x1, y1), (x2, y2)))
                                    line = QGraphicsLineItem(x1, y1, x2, y2)
                                    pen = QPen(color, 0)
                                    pen.setCosmetic(True)
                                    line.setPen(pen)
                                    group.addToGroup(line)
                            temp_paths.append(path)
                            temp_items.append((path, group))
                    elif entity.dxftype() == "LWPOLYLINE":
                        points = entity.get_points()
                        if len(points) >= 2:
                            path = []
                            group = SelectableGroup(color)
                            for i in range(len(points) - 1):
                                x1, y1 = points[i][0], -points[i][1]
                                x2, y2 = points[i + 1][0], -points[i + 1][1]
                                min_x, max_x = min(min_x, x1, x2), max(max_x, x1, x2)
                                min_y, max_y = min(min_y, y1, y2), max(max_y, y1, y2)
                                path.append(("line", (x1, y1), (x2, y2)))
                                line = QGraphicsLineItem(x1, y1, x2, y2)
                                pen = QPen(color, 0)
                                pen.setCosmetic(True)
                                line.setPen(pen)
                                group.addToGroup(line)
                            if entity.closed:
                                x1, y1 = points[-1][0], -points[-1][1]
                                x2, y2 = points[0][0], -points[0][1]
                                min_x, max_x = min(min_x, x1, x2), max(max_x, x1, x2)
                                min_y, max_y = min(min_y, y1, y2), max(max_y, y1, y2)
                                path.append(("line", (x1, y1), (x2, y2)))
                                line = QGraphicsLineItem(x1, y1, x2, y2)
                                pen = QPen(color, 0)
                                pen.setCosmetic(True)
                                line.setPen(pen)
                                group.addToGroup(line)
                            temp_paths.append(path)
                            temp_items.append((path, group))
                    elif entity.dxftype() == "CIRCLE":
                        center_x, center_y = entity.dxf.center.x, -entity.dxf.center.y
                        radius = entity.dxf.radius
                        min_x, max_x = min(min_x, center_x - radius), max(max_x, center_x + radius)
                        min_y, max_y = min(min_y, center_y - radius), max(max_y, center_y + radius)
                        ellipse = SelectableEllipseItem(center_x - radius, center_y - radius, 2 * radius, 2 * radius, color)
                        num_segments = 36
                        path = []
                        for i in range(num_segments):
                            angle1 = 2 * np.pi * i / num_segments
                            angle2 = 2 * np.pi * (i + 1) / num_segments
                            x1 = center_x + radius * np.cos(angle1)
                            y1 = center_y + radius * np.sin(angle1)
                            x2 = center_x + radius * np.cos(angle2)
                            y2 = center_y + radius * np.sin(angle2)
                            path.append(("line", (x1, y1), (x2, y2)))
                        temp_paths.append(path)
                        temp_items.append((path, ellipse))
                    elif entity.dxftype() == "ARC":
                        center_x, center_y = entity.dxf.center.x, -entity.dxf.center.y
                        radius = entity.dxf.radius
                        start_angle = math.radians(entity.dxf.start_angle)
                        end_angle = math.radians(entity.dxf.end_angle)
                        if end_angle < start_angle:
                            end_angle += 2 * math.pi
                        num_segments = 36
                        path = []
                        group = SelectableGroup(color)
                        prev_x, prev_y = None, None
                        for i in range(num_segments + 1):
                            t = i / num_segments
                            angle = start_angle + (end_angle - start_angle) * t
                            x = center_x + radius * math.cos(angle)
                            y = center_y + radius * math.sin(angle)
                            if i > 0:
                                path.append(("line", (prev_x, prev_y), (x, y)))
                                line = QGraphicsLineItem(prev_x, prev_y, x, y)
                                pen = QPen(color, 0)
                                pen.setCosmetic(True)
                                line.setPen(pen)
                                group.addToGroup(line)
                            prev_x, prev_y = x, y
                        min_x, max_x = min(min_x, center_x - radius), max(max_x, center_x + radius)
                        min_y, max_y = min(min_y, center_y - radius), max(max_y, center_y + radius)
                        temp_paths.append(path)
                        temp_items.append((path, group))
                    elif entity.dxftype() == "ELLIPSE":
                        center_x, center_y = entity.dxf.center.x, -entity.dxf.center.y
                        major_axis = entity.dxf.major_axis
                        ratio = entity.dxf.ratio
                        major_radius = math.sqrt(major_axis[0]**2 + major_axis[1]**2)
                        minor_radius = major_radius * ratio
                        rotation = math.atan2(major_axis[1], major_axis[0])
                        start_angle = entity.dxf.start_angle if hasattr(entity.dxf, 'start_angle') else 0
                        end_angle = entity.dxf.end_angle if hasattr(entity.dxf, 'end_angle') else 2 * math.pi
                        if end_angle < start_angle:
                            end_angle += 2 * math.pi
                        num_segments = 36
                        path = []
                        group = SelectableGroup(color)
                        prev_x, prev_y = None, None
                        for i in range(num_segments + 1):
                            t = i / num_segments
                            angle = start_angle + (end_angle - start_angle) * t
                            x_unrotated = major_radius * math.cos(angle)
                            y_unrotated = minor_radius * math.sin(angle)
                            x = center_x + x_unrotated * math.cos(rotation) - y_unrotated * math.sin(rotation)
                            y = center_y + x_unrotated * math.sin(rotation) + y_unrotated * math.cos(rotation)
                            if i > 0:
                                path.append(("line", (prev_x, prev_y), (x, y)))
                                line = QGraphicsLineItem(prev_x, prev_y, x, y)
                                pen = QPen(color, 0)
                                pen.setCosmetic(True)
                                line.setPen(pen)
                                group.addToGroup(line)
                            prev_x, prev_y = x, y
                        min_x, max_x = min(min_x, center_x - major_radius), max(max_x, center_x + major_radius)
                        min_y, max_y = min(min_y, center_y - minor_radius), max(max_y, center_y + minor_radius)
                        temp_paths.append(path)
                        temp_items.append((path, group))
                for path, item in temp_items:
                    self.paths.append(path)
                    self.graphics_items.append((path, item))
                    self.scene.addItem(item)
                self.bounding_min_x = min_x if min_x != float('inf') else 0
                self.bounding_max_y = min_y if min_y != float('inf') else 0
                self.bounding_max_x = max_x if max_x != float('-inf') else self.worktable_width
                self.bounding_min_y = max_y if max_y != float('-inf') else self.worktable_height
                center_x = (self.bounding_min_x + self.bounding_max_x) / 2
                center_y = (self.bounding_min_y + self.bounding_max_y) / 2
                offset_x = self.worktable_width / 2 - center_x
                offset_y = self.worktable_height / 2 - center_y
                for _, item in self.graphics_items:
                    item.moveBy(offset_x, offset_y)
                self.update_used_colors()
                self.label.setText(TRANSLATIONS[self.current_language]["loaded_dxf_file"].format(filename=os.path.basename(file_path)))
                self.button_gcode.setEnabled(True)
                self.update_simulation_paths()
                self.update_zero_point()
                self.view.fitInView(0, 0, self.worktable_width, self.worktable_height, Qt.KeepAspectRatio)
            except PermissionError as e:
                self.label.setText(TRANSLATIONS[self.current_language]["error_loading_dxf_permission"].format(error=str(e)))
            except FileNotFoundError as e:
                self.label.setText(TRANSLATIONS[self.current_language]["error_loading_dxf_not_found"].format(error=str(e)))
            except Exception as e:
                self.label.setText(TRANSLATIONS[self.current_language]["error_loading_dxf"].format(error=str(e)))

    def find_closest_point(self, zero_x, zero_y, active_layers):
        min_distance = float('inf')
        closest_point = None
        closest_path_index = None
        for i, path in enumerate(self.paths):
            for _, item in self.graphics_items:
                if path == item[0]:
                    color = item[1].normal_pen.color()
                    _, color_index = find_closest_color(color)
                    if color_index not in active_layers:
                        continue
                    for segment_type, p1, p2 in path:
                        for point in [p1, p2]:
                            x, y = point
                            offset = item[1].pos()
                            x += offset.x() - zero_x
                            y += offset.y() - zero_y
                            distance = math.sqrt(x**2 + y**2)
                            if distance < min_distance:
                                min_distance = distance
                                closest_point = (x, y)
                                closest_path_index = i
        return closest_point, closest_path_index

    def generate_gcode(self):
        active_layers = []
        for i in range(self.layer_box.layer_list.count()):
            item = self.layer_box.layer_list.item(i)
            data = item.data(Qt.UserRole)
            if data["checked"]:
                active_layers.append(i)
        if not active_layers:
            self.label.setText("No layers selected for G-Code generation")
            self.gcode_lines = []
            return
        if not self.paths:
            self.label.setText(TRANSLATIONS[self.current_language]["no_paths_for_gcode"])
            self.gcode_lines = []
            return
        try:
            for i in active_layers:
                speed = float(self.layer_settings[i]["speed"])
                power = float(self.layer_settings[i]["power"])
                if speed <= 0 or power <= 0:
                    self.label.setText(TRANSLATIONS[self.current_language]["speed_power_positive"])
                    return
        except ValueError:
            self.label.setText(TRANSLATIONS[self.current_language]["invalid_speed_power"])
            return
        self.gcode_lines = []
        self.gcode_lines.append("; G-Code generated by CNCSoft")
        self.gcode_lines.append("G90")
        self.gcode_lines.append("G21")
        zero_x, zero_y = self.zero_point.x(), self.zero_point.y()
        closest_point, closest_path_index = self.find_closest_point(zero_x, zero_y, active_layers)
        if closest_point is None:
            self.label.setText(TRANSLATIONS[self.current_language]["no_valid_points_gcode"])
            return
        current_pos = closest_point
        self.gcode_lines.append("M5")
        self.gcode_lines.append(f"G0 X{current_pos[0]:.3f} Y{current_pos[1]:.3f}")
        processed_paths = set()
        processed_paths.add(closest_path_index)
        for i in active_layers:
            speed = float(self.layer_settings[i]["speed"])
            power = float(self.layer_settings[i]["power"])
            self.gcode_lines.append(f"; Layer {i + 1}")
            self.gcode_lines.append(f"F{speed}")
            layer_paths = []
            for path_idx, path in enumerate(self.paths):
                for _, item in self.graphics_items:
                    if path == item[0]:
                        color = item[1].normal_pen.color()
                        _, color_index = find_closest_color(color)
                        if color_index == i and path_idx not in processed_paths:
                            layer_paths.append((path_idx, path, item[1]))
            for path_idx, path, item in layer_paths:
                processed_paths.add(path_idx)
                offset = item.pos()
                for segment_type, p1, p2 in path:
                    x1, y1 = p1[0] + offset.x() - zero_x, p1[1] + offset.y() - zero_y
                    x2, y2 = p2[0] + offset.x() - zero_x, p2[1] + offset.y() - zero_y
                    if current_pos != (x1, y1):
                        self.gcode_lines.append("M5")
                        self.gcode_lines.append(f"G0 X{x1:.3f} Y{y1:.3f}")
                        current_pos = (x1, y1)
                    self.gcode_lines.append("M3")
                    self.gcode_lines.append(f"G1 X{x2:.3f} Y{y2:.3f} S{power}")
                    current_pos = (x2, y2)
        while len(processed_paths) < len([p for p, _ in self.graphics_items if find_closest_color(p[1].normal_pen.color())[1] in active_layers]):
            min_distance = float('inf')
            next_path_index = None
            next_start_point = None
            for i, path in enumerate(self.paths):
                if i in processed_paths:
                    continue
                for _, item in self.graphics_items:
                    if path == item[0]:
                        color = item[1].normal_pen.color()
                        _, color_index = find_closest_color(color)
                        if color_index not in active_layers:
                            continue
                        for segment_type, p1, p2 in path:
                            x1, y1 = p1[0], p1[1]
                            offset = item[1].pos()
                            x1 += offset.x() - zero_x
                            y1 += offset.y() - zero_y
                            distance = math.sqrt((x1 - current_pos[0])**2 + (y1 - current_pos[1])**2)
                            if distance < min_distance:
                                min_distance = distance
                                next_path_index = i
                                next_start_point = (x1, y1)
            if next_path_index is None:
                break
            processed_paths.add(next_path_index)
            for _, item in self.graphics_items:
                if self.paths[next_path_index] == item[0]:
                    color = item[1].normal_pen.color()
                    _, color_index = find_closest_color(color)
                    speed = float(self.layer_settings[color_index]["speed"])
                    power = float(self.layer_settings[color_index]["power"])
                    break
            self.gcode_lines.append("M5")
            self.gcode_lines.append(f"G0 X{next_start_point[0]:.3f} Y{next_start_point[1]:.3f}")
            self.gcode_lines.append(f"F{speed}")
            current_pos = next_start_point
            path = self.paths[next_path_index]
            offset = item.pos()
            for segment_type, p1, p2 in path:
                x1, y1 = p1[0] + offset.x() - zero_x, p1[1] + offset.y() - zero_y
                x2, y2 = p2[0] + offset.x() - zero_x, p2[1] + offset.y() - zero_y
                if current_pos != (x1, y1):
                    self.gcode_lines.append("M5")
                    self.gcode_lines.append(f"G0 X{x1:.3f} Y{y1:.3f}")
                    current_pos = (x1, y1)
                self.gcode_lines.append("M3")
                self.gcode_lines.append(f"G1 X{x2:.3f} Y{y2:.3f} S{power}")
                current_pos = (x2, y2)
        self.gcode_lines.append("M5")
        self.gcode_lines.append("G0 X0 Y0")
        self.label.setText(TRANSLATIONS[self.current_language]["gcode_generated"])

    def update_simulation_paths(self):
        updated_paths = []
        min_x, min_y, max_x, max_y = self.calculate_objects_bounding_box()
        zero_x, zero_y = self.zero_point.x(), self.zero_point.y()
        for path, item in self.graphics_items:
            updated_path = []
            for segment_type, p1, p2 in path:
                x1, y1 = p1[0], p1[1]
                x2, y2 = p2[0], p2[1]
                p1_scene = item.mapToScene(QPointF(x1, y1))
                p2_scene = item.mapToScene(QPointF(x2, y2))
                new_p1 = (p1_scene.x() - zero_x, p1_scene.y() - zero_y)
                new_p2 = (p2_scene.x() - zero_x, p2_scene.y() - zero_y)
                updated_path.append((segment_type, new_p1, new_p2))
            updated_paths.append(updated_path)

if __name__ == "__main__":
    app = QApplication(sys.argv)
    window = CNCApp()
    window.show()
    sys.exit(app.exec_())